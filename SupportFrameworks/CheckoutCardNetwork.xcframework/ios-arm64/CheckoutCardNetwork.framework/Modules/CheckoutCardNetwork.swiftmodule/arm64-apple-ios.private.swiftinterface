// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios14.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-upcoming-feature StrictConcurrency -enable-bare-slash-regex -module-name CheckoutCardNetwork
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import Combine
import CryptoKit
import Foundation
import PassKit
import Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public struct CardDigitizationData {
  public let state: CheckoutCardNetwork.CardDigitizationState
  public let localPKPass: PassKit.PKPass?
  public let remotePKPass: PassKit.PKPass?
}
public enum CardDigitizationState : Swift.String, Swift.Decodable {
  case digitized
  case notDigitized
  case pendingIDVLocal
  case pendingIDVRemote
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CardDigitizationResult {
  case success(CheckoutCardNetwork.CardDigitizationData)
  case failure(CheckoutCardNetwork.CardNetworkError)
}
public enum CardDetailCopyResult {
  case success
  case failure(CheckoutCardNetwork.CardNetworkError)
}
@_hasMissingDesignatedInitializers final public class CheckoutCardService : CheckoutCardNetwork.CardService {
  nonisolated(unsafe) public static let version: CheckoutCardNetwork.CardServiceVersion
  required convenience public init(environment: CheckoutCardNetwork.CardNetworkEnvironment, logger: any CheckoutCardNetwork.NetworkLogger)
  final public func isTokenValid(_ token: CheckoutCardNetwork.Token) -> Swift.Bool
  final public func getCards(sessionToken: CheckoutCardNetwork.Token, statuses: Swift.Set<CheckoutCardNetwork.CardState>? = nil) async throws -> [CheckoutCardNetwork.Card]
  final public func getCard(withID cardID: Swift.String, sessionToken: CheckoutCardNetwork.Token) async throws -> CheckoutCardNetwork.Card
  final public func createCard(from cardModel: CheckoutCardNetwork.CardCreationModel, sessionToken: Swift.String, completionHandler: @escaping ((CheckoutCardNetwork.CheckoutCardService.CardResult) -> Swift.Void))
  @objc deinit
}
public struct CardCreationModel : Swift.Encodable {
  public init(type: CheckoutCardNetwork.CardType, cardholderID: Swift.String, lifetime: Swift.Int?, reference: Swift.String?, cardProductID: Swift.String?, displayName: Swift.String, shippingInstructions: CheckoutCardNetwork.CardShippingInstructions?, isSingleUse: Swift.Bool?, isCreatedActive: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct SecurityCodeViewConfiguration : Swift.Sendable {
  public init(font: UIKit.UIFont, textColor: UIKit.UIColor)
}
public struct WalletCardDetails {
  public let cardId: Swift.String
  public let cardTitle: Swift.String
  public let cardArt: UIKit.UIImage
  public init(cardId: Swift.String, cardTitle: Swift.String, cardArt: UIKit.UIImage)
}
extension CheckoutCardNetwork.CheckoutCardService {
  final public func configurePushProvisioning(cardholderID: Swift.String, appGroupId: Swift.String, configuration: CheckoutCardNetwork.ProvisioningConfiguration, walletCardsList: [CheckoutCardNetwork.WalletCardDetails]) async throws
  final public func getCardDigitizationState(cardID: Swift.String, token: Swift.String) async throws -> CheckoutCardNetwork.CardDigitizationData
  final public func addCardToAppleWallet(cardID: Swift.String, token: CheckoutCardNetwork.Token, viewController: UIKit.UIViewController) async throws
}
@objc @_inheritsConvenienceInitializers @available(iOS 14.0, *)
open class NonUiProvisioningExtensionHandler : PassKit.PKIssuerProvisioningExtensionHandler {
  public func initLogger(logger: any CheckoutCardNetwork.NetworkLogger)
  @objc override dynamic open func status(completion: @escaping (PassKit.PKIssuerProvisioningExtensionStatus) -> Swift.Void)
  @objc override dynamic open func passEntries(completion: @escaping ([PassKit.PKIssuerProvisioningExtensionPassEntry]) -> Swift.Void)
  @objc override dynamic open func remotePassEntries(completion: @escaping ([PassKit.PKIssuerProvisioningExtensionPassEntry]) -> Swift.Void)
  @objc override dynamic open func generateAddPaymentPassRequestForPassEntryWithIdentifier(_ identifier: Swift.String, configuration: PassKit.PKAddPaymentPassRequestConfiguration, certificateChain certificates: [Foundation.Data], nonce: Foundation.Data, nonceSignature: Foundation.Data, completionHandler completion: @escaping (PassKit.PKAddPaymentPassRequest?) -> Swift.Void)
  open func onError(_ error: CheckoutCardNetwork.CardNetworkError.ProvisioningExtensionFailure)
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 14.0, *)
public protocol UiProvisioningExtensionAuthorizationProviding : PassKit.PKIssuerProvisioningExtensionAuthorizationProviding {
}
@available(iOS 14.0, *)
extension CheckoutCardNetwork.UiProvisioningExtensionAuthorizationProviding {
  public func login(token: Swift.String, logger: any CheckoutCardNetwork.NetworkLogger, completion: @escaping (CheckoutCardNetwork.CardNetworkError.ProvisioningExtensionFailure?) -> Swift.Void)
}
public protocol CardService {
  typealias SecureDisplay = UIKit.UIView
  typealias SecureResult = Swift.Result<UIKit.UIView, CheckoutCardNetwork.CardNetworkError>
  typealias SecurePropertiesResult = Swift.Result<(pan: UIKit.UIView, securityCode: UIKit.UIView), CheckoutCardNetwork.CardNetworkError>
  typealias CardResult = Swift.Result<CheckoutCardNetwork.Card, CheckoutCardNetwork.CardNetworkError>
  typealias CardListResult = Swift.Result<[CheckoutCardNetwork.Card], CheckoutCardNetwork.CardNetworkError>
  static var version: CheckoutCardNetwork.CardServiceVersion { get }
  init(environment: CheckoutCardNetwork.CardNetworkEnvironment, logger: any CheckoutCardNetwork.NetworkLogger)
  func isTokenValid(_ token: CheckoutCardNetwork.Token) -> Swift.Bool
  func displayPin(forCard cardID: Swift.String, displayConfiguration: CheckoutCardNetwork.PinViewConfiguration, singleUseToken: CheckoutCardNetwork.Token) async throws -> Self.SecureDisplay
  func displayPan(forCard cardID: Swift.String, displayConfiguration: CheckoutCardNetwork.PanViewConfiguration, singleUseToken: CheckoutCardNetwork.Token) async throws -> Self.SecureDisplay
  func copyPan(forCard cardID: Swift.String, singleUseToken: CheckoutCardNetwork.Token) async throws
  func displaySecurityCode(forCard cardID: Swift.String, displayConfiguration: CheckoutCardNetwork.SecurityCodeViewConfiguration, singleUseToken: CheckoutCardNetwork.Token) async throws -> Self.SecureDisplay
  func displayPanAndSecurityCode(forCard cardID: Swift.String, panViewConfiguration: CheckoutCardNetwork.PanViewConfiguration, securityCodeViewConfiguration: CheckoutCardNetwork.SecurityCodeViewConfiguration, singleUseToken: CheckoutCardNetwork.Token) async throws -> (pan: Self.SecureDisplay, securityCode: Self.SecureDisplay)
  func activateCard(cardID: Swift.String, sessionToken: CheckoutCardNetwork.Token) async throws
  func suspendCard(cardID: Swift.String, reason: CheckoutCardNetwork.CardSuspendReason?, sessionToken: CheckoutCardNetwork.Token) async throws
  func revokeCard(cardID: Swift.String, reason: CheckoutCardNetwork.CardRevokeReason?, sessionToken: CheckoutCardNetwork.Token) async throws
  func getCards(sessionToken: CheckoutCardNetwork.Token, statuses: Swift.Set<CheckoutCardNetwork.CardState>?) async throws -> [CheckoutCardNetwork.Card]
  func getCard(withID cardID: Swift.String, sessionToken: CheckoutCardNetwork.Token) async throws -> CheckoutCardNetwork.Card
  func createCard(from cardModel: CheckoutCardNetwork.CardCreationModel, sessionToken: Swift.String, completionHandler: @escaping ((Self.CardResult) -> Swift.Void))
  func configurePushProvisioning(cardholderID: Swift.String, appGroupId: Swift.String, configuration: CheckoutCardNetwork.ProvisioningConfiguration, walletCardsList: [CheckoutCardNetwork.WalletCardDetails]) async throws
  func getCardDigitizationState(cardID: Swift.String, token: Swift.String) async throws -> CheckoutCardNetwork.CardDigitizationData
  func addCardToAppleWallet(cardID: Swift.String, token: CheckoutCardNetwork.Token, viewController: UIKit.UIViewController) async throws
}
public struct CardServiceVersion {
  public let name: Swift.String
  public let number: Swift.String
}
public struct PanViewConfiguration : Swift.Sendable {
  public init(font: UIKit.UIFont, textColor: UIKit.UIColor, formatSeparator: Swift.String)
}
public struct CardShippingInstructions : Swift.Encodable {
  public init(recipient: Swift.String, address: CheckoutCardNetwork.CardShippingInstructions.Address, comments: Swift.String?)
  public func encode(to encoder: any Swift.Encoder) throws
}
extension CheckoutCardNetwork.CardShippingInstructions {
  public struct Address : Swift.Encodable {
    public init(addressLine1: Swift.String, addressLine2: Swift.String?, city: Swift.String, state: Swift.String?, postCode: Swift.String, countryCode: Swift.String)
    public func encode(to encoder: any Swift.Encoder) throws
  }
}
public struct Card : Swift.Decodable, Swift.Equatable {
  public let id: Swift.String
  public let displayName: Swift.String
  public let expiryDate: CheckoutCardNetwork.CardExpiryDate
  public let panLast4Digits: Swift.String
  public let state: CheckoutCardNetwork.CardState
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: CheckoutCardNetwork.Card, b: CheckoutCardNetwork.Card) -> Swift.Bool
}
public enum CardType : Swift.String, Swift.Codable {
  case physical
  case virtual
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct ProvisioningConfiguration : Swift.Codable {
  public let issuerID: Swift.String
  public let serviceRSAExponent: Foundation.Data
  public let serviceRSAModulus: Foundation.Data
  public let serviceURLString: Swift.String
  public let digitalServiceURLString: Swift.String
  public init(issuerID: Swift.String, serviceRSAExponent: Foundation.Data, serviceRSAModulus: Foundation.Data, serviceURLString: Swift.String, digitalServiceURLString: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum CardSuspendReason : Swift.String {
  case lost
  case stolen
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CardState : Swift.String, Swift.Decodable {
  case active
  case inactive
  case suspended
  case revoked
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CardNetworkError : Swift.Error, Swift.Equatable {
  public enum PushProvisioningFailure : Swift.Error, Swift.Equatable {
    case cancelled
    case configurationFailure
    case operationFailure(hint: Swift.String)
    public static func == (a: CheckoutCardNetwork.CardNetworkError.PushProvisioningFailure, b: CheckoutCardNetwork.CardNetworkError.PushProvisioningFailure) -> Swift.Bool
  }
  public enum ProvisioningExtensionFailure : Swift.Error, Swift.Equatable {
    case walletExtensionAppGroupIDNotFound
    case cardNotFound
    case deviceEnvironmentUnsafe
    case operationFailure
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CheckoutCardNetwork.CardNetworkError.ProvisioningExtensionFailure, b: CheckoutCardNetwork.CardNetworkError.ProvisioningExtensionFailure) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DigitizationStateFailure : Swift.Error, Swift.Equatable {
    case configurationFailure
    case operationFailure
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CheckoutCardNetwork.CardNetworkError.DigitizationStateFailure, b: CheckoutCardNetwork.CardNetworkError.DigitizationStateFailure) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum CopySensitiveDataError : Swift.Error, Swift.Equatable {
    case copyFailure
    case dataNotViewed
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CheckoutCardNetwork.CardNetworkError.CopySensitiveDataError, b: CheckoutCardNetwork.CardNetworkError.CopySensitiveDataError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  case authenticationFailure
  case deviceNotSupported
  case insecureDevice
  case invalidRequest(hint: Swift.String)
  case invalidRequestInput
  case misconfigured(hint: Swift.String)
  case serverIssue
  case unauthenticated
  case secureOperationsFailure
  case parsingFailure
  case pushProvisioningFailure(failure: CheckoutCardNetwork.CardNetworkError.PushProvisioningFailure)
  case fetchDigitizationStateFailure(failure: CheckoutCardNetwork.CardNetworkError.DigitizationStateFailure)
  case unableToCopy(failure: CheckoutCardNetwork.CardNetworkError.CopySensitiveDataError)
  case notFound
  public static func == (a: CheckoutCardNetwork.CardNetworkError, b: CheckoutCardNetwork.CardNetworkError) -> Swift.Bool
}
extension CheckoutCardNetwork.CheckoutCardService {
  final public func activateCard(cardID: Swift.String, sessionToken: CheckoutCardNetwork.Token) async throws
  final public func suspendCard(cardID: Swift.String, reason: CheckoutCardNetwork.CardSuspendReason?, sessionToken: CheckoutCardNetwork.Token) async throws
  final public func revokeCard(cardID: Swift.String, reason: CheckoutCardNetwork.CardRevokeReason?, sessionToken: CheckoutCardNetwork.Token) async throws
}
public struct CardExpiryDate : Swift.Equatable {
  public let month: Swift.String
  public let year: Swift.String
  public static func == (a: CheckoutCardNetwork.CardExpiryDate, b: CheckoutCardNetwork.CardExpiryDate) -> Swift.Bool
}
extension CheckoutCardNetwork.CheckoutCardService {
  @_Concurrency.MainActor final public func displayPin(forCard cardID: Swift.String, displayConfiguration: CheckoutCardNetwork.PinViewConfiguration, singleUseToken: CheckoutCardNetwork.Token) async throws -> CheckoutCardNetwork.CheckoutCardService.SecureDisplay
  @_Concurrency.MainActor final public func displayPan(forCard cardID: Swift.String, displayConfiguration: CheckoutCardNetwork.PanViewConfiguration, singleUseToken: CheckoutCardNetwork.Token) async throws -> CheckoutCardNetwork.CheckoutCardService.SecureDisplay
  final public func displaySecurityCode(forCard cardID: Swift.String, displayConfiguration: CheckoutCardNetwork.SecurityCodeViewConfiguration, singleUseToken: CheckoutCardNetwork.Token) async throws -> CheckoutCardNetwork.CheckoutCardService.SecureDisplay
  @_Concurrency.MainActor final public func displayPanAndSecurityCode(forCard cardID: Swift.String, panViewConfiguration: CheckoutCardNetwork.PanViewConfiguration, securityCodeViewConfiguration: CheckoutCardNetwork.SecurityCodeViewConfiguration, singleUseToken: CheckoutCardNetwork.Token) async throws -> (pan: CheckoutCardNetwork.CheckoutCardService.SecureDisplay, securityCode: CheckoutCardNetwork.CheckoutCardService.SecureDisplay)
  @_Concurrency.MainActor final public func copyPan(forCard cardID: Swift.String, singleUseToken: CheckoutCardNetwork.Token) async throws
}
public protocol NetworkLogger : AnyObject, Swift.Sendable {
  var sessionID: Swift.String { get }
  func log(error: any Swift.Error, additionalInfo: [Swift.String : Swift.String])
}
public typealias Token = Swift.String
public enum OperationResult : Swift.Equatable {
  case success
  case failure(CheckoutCardNetwork.CardNetworkError)
  public static func == (a: CheckoutCardNetwork.OperationResult, b: CheckoutCardNetwork.OperationResult) -> Swift.Bool
}
public enum CardNetworkEnvironment : Swift.String {
  case sandbox
  case production
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CardRevokeReason : Swift.String {
  case lost
  case stolen
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct PinViewConfiguration : Swift.Sendable {
  public init(font: UIKit.UIFont, textColor: UIKit.UIColor)
}
extension CheckoutCardNetwork.CardDigitizationState : Swift.Equatable {}
extension CheckoutCardNetwork.CardDigitizationState : Swift.Hashable {}
extension CheckoutCardNetwork.CardDigitizationState : Swift.RawRepresentable {}
extension CheckoutCardNetwork.CardNetworkEnvironment : Swift.Equatable {}
extension CheckoutCardNetwork.CardNetworkEnvironment : Swift.Hashable {}
extension CheckoutCardNetwork.CardNetworkEnvironment : Swift.RawRepresentable {}
extension CheckoutCardNetwork.CardType : Swift.Equatable {}
extension CheckoutCardNetwork.CardType : Swift.Hashable {}
extension CheckoutCardNetwork.CardType : Swift.RawRepresentable {}
extension CheckoutCardNetwork.CardSuspendReason : Swift.Equatable {}
extension CheckoutCardNetwork.CardSuspendReason : Swift.Hashable {}
extension CheckoutCardNetwork.CardSuspendReason : Swift.RawRepresentable {}
extension CheckoutCardNetwork.CardState : Swift.Equatable {}
extension CheckoutCardNetwork.CardState : Swift.Hashable {}
extension CheckoutCardNetwork.CardState : Swift.RawRepresentable {}
extension CheckoutCardNetwork.CardNetworkError.ProvisioningExtensionFailure : Swift.Hashable {}
extension CheckoutCardNetwork.CardNetworkError.DigitizationStateFailure : Swift.Hashable {}
extension CheckoutCardNetwork.CardNetworkError.CopySensitiveDataError : Swift.Hashable {}
extension CheckoutCardNetwork.CardRevokeReason : Swift.Equatable {}
extension CheckoutCardNetwork.CardRevokeReason : Swift.Hashable {}
extension CheckoutCardNetwork.CardRevokeReason : Swift.RawRepresentable {}
